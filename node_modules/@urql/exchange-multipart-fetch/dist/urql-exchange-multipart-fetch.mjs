import { share as e, mergeMap as r, filter as t, onPush as n, takeUntil as a, merge as o } from "wonka";

import { extractFiles as i } from "extract-files";

import { makeFetchBody as c, makeFetchURL as u, makeFetchOptions as s, makeFetchSource as p } from "@urql/core/internal";

function _extends() {
  return (_extends = Object.assign || function(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = arguments[r];
      for (var n in t) {
        if (Object.prototype.hasOwnProperty.call(t, n)) {
          e[n] = t[n];
        }
      }
    }
    return e;
  }).apply(this, arguments);
}

function multipartFetchExchange(f) {
  var d = f.forward;
  var h = f.dispatchDebug;
  return function(f) {
    var l = e(f);
    var v = r((function(e) {
      var r = t((function(r) {
        return "teardown" === r.kind && r.key === e.key;
      }))(l);
      var o = i(_extends({}, e.variables));
      var f = o.files;
      var d = c({
        query: e.query,
        variables: o.clone
      });
      var v;
      var m;
      if (f.size) {
        v = u(e);
        if ("application/json" === (m = s(e)).headers["content-type"]) {
          delete m.headers["content-type"];
        }
        m.method = "POST";
        m.body = new FormData;
        m.body.append("operations", JSON.stringify(d));
        var y = {};
        var b = 0;
        f.forEach((function(e) {
          y[++b] = e.map((function(e) {
            return "variables." + e;
          }));
        }));
        m.body.append("map", JSON.stringify(y));
        b = 0;
        f.forEach((function(e, r) {
          m.body.append("" + ++b, r, r.name);
        }));
      } else {
        m = s(e, d);
        v = u(e, d);
      }
      "production" !== process.env.NODE_ENV && h({
        type: "fetchRequest",
        message: "A fetch request is being executed.",
        operation: e,
        data: {
          url: v,
          fetchOptions: m
        },
        source: "multipartFetchExchange"
      });
      return n((function(r) {
        var t = !r.data ? r.error : void 0;
        "production" !== process.env.NODE_ENV && h({
          type: t ? "fetchError" : "fetchSuccess",
          message: "A " + (t ? "failed" : "successful") + " fetch response has been returned.",
          operation: e,
          data: {
            url: v,
            fetchOptions: m,
            value: t || r
          },
          source: "multipartFetchExchange"
        });
      }))(a(r)(p(e, v, m)));
    }))(t((function(e) {
      return "query" === e.kind || "mutation" === e.kind;
    }))(l));
    var m = d(t((function(e) {
      return "query" !== e.kind && "mutation" !== e.kind;
    }))(l));
    return o([ v, m ]);
  };
}

export { multipartFetchExchange };
//# sourceMappingURL=urql-exchange-multipart-fetch.mjs.map
